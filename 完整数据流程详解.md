# 完整数据流程详解

本文档详细说明从原始数据到最终输出的完整流程，包括每个环节涉及的文件、数据维度变化和处理逻辑。

---

## 📋 目录

1. [阶段0：原始输入文件](#阶段0原始输入文件)
2. [阶段1：数据划分（Train/Val Split）](#阶段1数据划分trainval-split)
3. [阶段2：基因对齐与预处理](#阶段2基因对齐与预处理)
4. [阶段3：Gene-level Autoencoder 编码](#阶段3gene-level-autoencoder-编码)
5. [阶段4：Per-gene PCA 降维](#阶段4per-gene-pca-降维)
6. [阶段5：DeepProg 训练与预测](#阶段5deepprog-训练与预测)
7. [阶段6：结果输出](#阶段6结果输出)
8. [数据维度变化总览](#数据维度变化总览)

---

## 阶段0：原始输入文件

### 📁 文件位置
```
data/
├── rna.tsv(.gz)          # RNA 表达矩阵
├── meth.tsv(.gz)         # 甲基化矩阵
├── mir.tsv(.gz)          # miRNA 表达矩阵（可选）
├── survival.tsv          # 生存信息
├── mir_to_gene.tsv       # miRNA 到基因映射（使用 MIR 时必需）
└── entrez2ensg.tsv       # Entrez ID 到 ENSG 映射（可选）
```

### 📊 文件格式与维度

#### 1. `rna.tsv` / `meth.tsv` / `mir.tsv`
- **格式**：TSV 表格（支持 `.gz` 压缩）
- **维度**：`(G × S)` 或 `(S × G)`
  - `G` = 基因/特征数量（RNA/METH: ~5000-20000 基因，MIR: ~1000-2000 miRNA）
  - `S` = 样本数量（例如：360）
- **内容**：
  - 行：基因/特征 ID（如 `ENSG00000123456` 或 `hsa-let-7a-1`）
  - 列：样本 ID（如 `GSM2806761`）
  - 值：表达/甲基化水平（浮点数）
- **自动转置**：如果行名以 `TCGA` 或 `Samples` 开头，脚本会自动转置为 `(G × S)`
- **读取位置**：`simdeep/tools/external_validation.py:73-75`

#### 2. `survival.tsv`
- **格式**：TSV 表格，必须包含三列
- **列名**：`Samples`, `days`, `event`
- **维度**：`(S × 3)`
- **内容示例**：
  ```text
  Samples        days    event
  GSM2806761     1234    1
  GSM4779598     567     0
  ...
  ```
- **说明**：
  - `Samples`：样本 ID（必须与组学矩阵中的列名/行名匹配）
  - `days`：生存时间（天）
  - `event`：结局事件（1=死亡，0=删失）
- **读取位置**：`simdeep/tools/external_validation.py:50-51`

#### 3. `mir_to_gene.tsv`（使用 MIR 时必需）
- **格式**：TSV 表格
- **列名**：`mirna_id`, `gene_symbol`（可选的第三列为权重）
- **维度**：`(M × 2)` 或 `(M × 3)`
  - `M` = miRNA-基因映射对数量（例如：~1500 行）
- **内容示例**：
  ```text
  mirna_id       gene_symbol
  hsa-let-7a-1   KRAS
  hsa-let-7a-1   NRAS
  hsa-let-7a-1   MYC
  ...
  ```
- **作用**：将 miRNA 表达映射到基因空间，以便与其他组学对齐
- **使用位置**：`simdeep/tools/generate_gene_pca_tsv.py:219-240`

#### 4. `entrez2ensg.tsv`（可选）
- **格式**：TSV 表格
- **作用**：当特征为 Entrez ID 时，映射到 ENSG 格式，保证跨模态对齐
- **使用位置**：`simdeep/survival_utils.py:390-406`

---

## 阶段1：数据划分（Train/Val Split）

### 🔄 处理流程

**执行位置**：`simdeep/tools/external_validation.py:49-103`

1. **读取 `survival.tsv`**
   - 获取所有样本 ID 列表
   - 维度：`(S,)` 样本 ID 数组

2. **随机划分训练集和验证集**
   - 默认比例：75% 训练集，25% 验证集（可通过 `--train-ratio` 调整）
   - 使用 `seed` 参数保证可复现性
   - 结果：
     - `train_ids`：训练集样本 ID（例如：270 个样本）
     - `val_ids`：验证集样本 ID（例如：90 个样本）

3. **划分各组学矩阵**
   - 对每个组学（RNA、METH、MIR）：
     - 从原始矩阵中提取训练集列：`(G × S_train)`
     - 从原始矩阵中提取验证集列：`(G × S_val)`

4. **保存划分后的数据**

### 📁 生成的文件

#### 训练集原始数据
```
data/train/raw/
├── rna.tsv        # (G × S_train)，例如 (5000 × 270)
├── meth.tsv       # (G × S_train)，例如 (5000 × 270)
└── mir.tsv        # (G_mir × S_train)，例如 (1000 × 270)（如果存在）
```

#### 验证集原始数据
```
data/val/raw/
├── rna.tsv        # (G × S_val)，例如 (5000 × 90)
├── meth.tsv       # (G × S_val)，例如 (5000 × 90)
└── mir.tsv        # (G_mir × S_val)，例如 (1000 × 90)（如果存在）
```

#### 生存信息文件
```
data/train/train_survival.tsv  # (S_train × 3)
data/val/val_survival.tsv      # (S_val × 3)
```

### 📊 数据维度变化

| 输入 | 维度 | 输出 | 维度 |
|------|------|------|------|
| `data/rna.tsv` | `(G × S)` | `data/train/raw/rna.tsv` | `(G × S_train)` |
| `data/rna.tsv` | `(G × S)` | `data/val/raw/rna.tsv` | `(G × S_val)` |
| `data/survival.tsv` | `(S × 3)` | `data/train/train_survival.tsv` | `(S_train × 3)` |
| `data/survival.tsv` | `(S × 3)` | `data/val/val_survival.tsv` | `(S_val × 3)` |

**示例**（实际项目数据，`S=361`, `train_ratio=0.75`）：
- `S_train = 270`, `S_val = 91`
- `train/raw/rna.tsv`: `(15629 × 270)`（原始基因数，未对齐）
- `val/raw/rna.tsv`: `(15629 × 91)`（原始基因数，未对齐）
- **注意**：在阶段2的基因对齐后，会统一到 `G = 15055` 个共同基因

---

## 阶段2：基因对齐与预处理

### 🔄 处理流程

**执行位置**：`simdeep/tools/generate_gene_pca_tsv.py:128-177`

#### 2.1 读取原始数据

**代码位置**：`simdeep/tools/generate_gene_pca_tsv.py:118-133`

1. **读取各组学矩阵**
   - 从 `train/raw/` 或 `val/raw/` 读取各组学矩阵
   - 支持多种文件名变体（`rna.tsv`, `mrna.tsv`, `meth.tsv`, `mir.tsv`, `mirna.tsv`）
   - 支持压缩格式（`.gz`）

2. **自动转置检测**
   - **代码位置**：`simdeep/tools/generate_gene_pca_tsv.py:137-145`
   - 如果行名（index）以 `TCGA` 或 `Samples` 开头，自动转置
   - 转置后格式统一为：**行=基因，列=样本**（`G × S`）

**原始数据示例**（实际项目数据）：
- `rna.tsv`：格式为 `(S × G)`，转置后为 `(15629 × 361)`
  - 原始：361 个样本 × 15629 个基因
  - 转置后：15629 个基因 × 361 个样本
- `meth.tsv`：格式为 `(S × G)`，转置后为 `(19883 × 361)`
  - 原始：361 个样本 × 19883 个基因
  - 转置后：19883 个基因 × 361 个样本

#### 2.2 样本对齐

**代码位置**：`simdeep/tools/generate_gene_pca_tsv.py:151-158`

1. **取样本交集**
   ```python
   common = set(mrna_df.columns) & set(meth_df.columns)
   if mir_df is not None:
       common = common & set(mir_df.columns)
   samples = sorted(list(common))
   ```

2. **结果**
   - `samples` = 所有组学的共同样本列表
   - 示例：如果 RNA 有 361 个样本，METH 有 361 个样本，交集也是 361 个样本
   - 如果某个样本在某个组学中缺失，会被排除

3. **提取共同样本**
   ```python
   mrna_df = mrna_df[samples]      # 只保留共同样本列
   meth_df = meth_df[samples]       # 只保留共同样本列
   if mir_df is not None:
       mir_df = mir_df[samples]     # 只保留共同样本列
   ```

#### 2.3 基因对齐（关键步骤）

**代码位置**：`simdeep/tools/generate_gene_pca_tsv.py:159-162`

这是**将不同组学的基因数统一到共同基因数**的关键步骤。

1. **取基因交集**
   ```python
   common_genes = list(set(mrna_df.index) & set(meth_df.index))
   common_genes.sort()
   ```

2. **实际数据示例**：
   - **RNA 原始基因数**：15629 个基因
   - **METH 原始基因数**：19883 个基因
   - **共同基因数**：15055 个基因（交集）
   - **被排除的基因**：
     - RNA 独有：15629 - 15055 = 574 个基因
     - METH 独有：19883 - 15055 = 4828 个基因

3. **提取共同基因**
   ```python
   mrna_df = mrna_df.loc[common_genes]   # 只保留共同基因行
   meth_df = meth_df.loc[common_genes]   # 只保留共同基因行
   ```

4. **结果维度**：
   - 转置前：`(15629 × 361)` → 对齐后：`(15055 × 361)`
   - 转置前：`(19883 × 361)` → 对齐后：`(15055 × 361)`
   - **统一后的基因数 `G = 15055`**（不再是 5000，而是实际交集数量）

**重要说明**：
- 这个对齐过程确保了所有组学使用**相同的基因集合**
- 只有同时存在于 RNA 和 METH 中的基因才会被保留
- 后续所有处理都基于这 15055 个共同基因进行

#### 2.4 miRNA 映射到基因空间（如果提供了 `mir_to_gene.tsv`）

**代码位置**：`simdeep/tools/generate_gene_pca_tsv.py:219-240`

1. **读取映射文件**
   - 读取 `mir_to_gene.tsv`，构建 miRNA → 基因的映射关系
   - 格式：`mirna_id\tgene_symbol\tweight`（权重可选）

2. **映射过程**
   - **关键点**：映射矩阵 `M` 的列数固定为 `len(gene_list)`，其中 `gene_list = common_genes`（15055个）
   - **代码逻辑**：
     ```python
     gene_to_idx = {g:i for i,g in enumerate(gene_list)}  # gene_list 是 common_genes（15055个）
     M = np.zeros((len(mir_ids), len(gene_list)), dtype=np.float32)  # 列数固定为15055
     for m,g,w in map_rows:
         if m in mir_to_idx and g in gene_to_idx:  # 只处理在 common_genes 中的基因
             M[mir_to_idx[m], gene_to_idx[g]] += w
     X_gene_mir = X_mir @ M  # (S × n_mirna) @ (n_mirna × 15055) → (S × 15055)
     ```
   - **结果**：`X_gene_mir` 的维度固定为 `(S × 15055)`，与 RNA/METH 完全对齐

3. **映射基因数处理说明**
   - **如果映射文件中的基因数 > 15055**：
     - 映射矩阵 `M` 的列数仍然是 15055（等于 `common_genes` 的数量）
     - 映射文件中不在 `common_genes` 中的基因会被**自动忽略**（因为 `gene_to_idx` 只包含 `common_genes`）
     - 结果：只有映射到 `common_genes` 的 miRNA 才会被保留
   
   - **如果映射文件中的基因数 < 15055**：
     - 映射矩阵 `M` 的列数仍然是 15055
     - 映射文件中没有对应关系的基因位置会被填充为 0
     - 结果：`X_gene_mir` 中未映射的基因位置为 0（或接近0，取决于归一化）

4. **归一化处理**
   - 对映射矩阵 `M` 按行归一化（每个 miRNA 的权重和为1）
   - 如果多个 miRNA 映射到同一个基因，使用加权平均
   - 确保映射后的表达值在合理范围内

#### 2.5 数据预处理

**代码位置**：`simdeep/tools/generate_gene_pca_tsv.py:163-177`

**为什么需要转置？**

1. **第一次转置（S×G → G×S）**：
   - **目的**：统一数据格式，方便进行按基因的标准化
   - **原因**：Z-score 标准化需要按基因（行）计算均值和标准差
   - **代码**：`maybe_transpose()` 将数据转为 `(G × S)` 格式（行=基因，列=样本）
   - **好处**：`df.mean(axis=1)` 可以按行（基因）计算统计量

2. **第二次转置（G×S → S×G）**：
   - **目的**：适配后续 autoencoder 的输入格式
   - **原因**：GeneEnc autoencoder 期望输入格式为 `(S × G)`（样本×基因）
   - **代码**：`X_mrna = mrna_z.values.T` 转置为 `(S × G)` 格式
   - **好处**：每个样本是一个向量，包含所有基因的值

**处理步骤**：

1. **缺失值填充**
   ```python
   mrna_df = mrna_df.fillna(mrna_df.mean(axis=1))   # 用基因的平均值填充
   meth_df = meth_df.fillna(meth_df.mean(axis=1))
   if mir_df is not None:
       mir_df = mir_df.fillna(mir_df.mean(axis=1))
   ```

2. **Z-score 标准化**（在 G×S 格式下进行）
   ```python
   def zscore(df):
       m = df.mean(axis=1)      # 按基因（行）计算均值
       s = df.std(axis=1)       # 按基因（行）计算标准差
       s[s == 0] = 1.0          # 避免除零
       return (df.sub(m, axis=0)).div(s, axis=0)
   
   mrna_z = zscore(mrna_df)    # (15055 × 361) → (15055 × 361)，每行（基因）标准化
   meth_z = zscore(meth_df)
   if mir_df is not None:
       mirna_z = zscore(mir_df)
   ```

3. **转置为样本×基因格式**（适配 autoencoder）
   ```python
   X_mrna = mrna_z.values.T.astype(np.float32)   # (15055 × 361) → (361 × 15055)
   X_meth = meth_z.values.T.astype(np.float32)   # (19883 × 361) → (361 × 15055)
   X_mir = mirna_z.values.T.astype(np.float32) if mir_df is not None else None
   ```
   - 结果：`X_mrna`, `X_meth`, `X_mir`（如果存在）
     - 维度：`(S × G)`，其中 `G = 15055`（共同基因数）
     - 格式：行=样本，列=基因（适配 autoencoder 输入）

### 📁 涉及的文件

**输入文件**：
- `data/train/raw/rna.tsv`
- `data/train/raw/meth.tsv`
- `data/train/raw/mir.tsv`（如果存在）
- `data/mir_to_gene.tsv`（如果使用 MIR）

**中间变量**（内存中，不保存）：
- `X_mrna_z`: `(S × G)` - 标准化后的 RNA 数据
- `X_meth_z`: `(S × G)` - 标准化后的 METH 数据
- `X_mirna_z`: `(S × G)` - 标准化后的 MIR 数据（如果存在）

### 📊 数据维度变化

| 输入 | 维度 | 处理步骤 | 输出 | 维度 |
|------|------|---------|------|------|
| `train/raw/rna.tsv` | `(15629 × S_train)` | 1. 转置检测<br>2. 样本对齐<br>3. **基因对齐**（取交集）<br>4. 缺失值填充<br>5. Z-score 标准化<br>6. 转置 | `X_mrna` | `(S_train × 15055)` |
| `train/raw/meth.tsv` | `(19883 × S_train)` | 1. 转置检测<br>2. 样本对齐<br>3. **基因对齐**（取交集）<br>4. 缺失值填充<br>5. Z-score 标准化<br>6. 转置 | `X_meth` | `(S_train × 15055)` |
| `train/raw/mir.tsv` | `(G_mir × S_train)` | 1. 转置检测<br>2. 样本对齐<br>3. miRNA→基因映射<br>4. **基因对齐**（取交集）<br>5. 缺失值填充<br>6. Z-score 标准化<br>7. 转置 | `X_mir` | `(S_train × 15055)` |

**详细维度变化示例**（实际项目数据，`S_train=270`）：

**RNA 数据流**：
```
原始: (361 × 15629)  [行=样本，列=基因]
  ↓ 转置检测（行名不是 TCGA/Samples，不转置）
转置后: (15629 × 361)  [行=基因，列=样本]
  ↓ 样本对齐（取交集，假设 361 个样本都在）
样本对齐后: (15629 × 361)
  ↓ 基因对齐（取 RNA 和 METH 的交集）
基因对齐后: (15055 × 361)  ← 关键：从 15629 减少到 15055
  ↓ 缺失值填充 + Z-score 标准化
标准化后: (15055 × 361)
  ↓ 转置为样本×基因格式
最终: (361 × 15055)  [行=样本，列=基因]
训练集: (270 × 15055)  [只取训练集样本]
```

**METH 数据流**：
```
原始: (361 × 19883)  [行=样本，列=基因]
  ↓ 转置检测
转置后: (19883 × 361)  [行=基因，列=样本]
  ↓ 样本对齐
样本对齐后: (19883 × 361)
  ↓ 基因对齐（取 RNA 和 METH 的交集）
基因对齐后: (15055 × 361)  ← 关键：从 19883 减少到 15055
  ↓ 缺失值填充 + Z-score 标准化
标准化后: (15055 × 361)
  ↓ 转置为样本×基因格式
最终: (361 × 15055)  [行=样本，列=基因]
训练集: (270 × 15055)  [只取训练集样本]
```

**MIR 数据流**（如果提供了 `mir.tsv` 和 `--mirna-map`）：
```
原始: (361 × G_mir)  [行=样本，列=miRNA，G_mir 为 miRNA 数量]
  ↓ 转置检测
转置后: (G_mir × 361)  [行=miRNA，列=样本]
  ↓ 样本对齐（取所有组学的样本交集）
样本对齐后: (G_mir × 361)
  ↓ miRNA→基因映射（使用 mir_to_gene.tsv）
映射后: (361 × 15055)  ← 关键：映射矩阵列数固定为 15055（common_genes）
  - 映射文件中不在 common_genes 的基因会被忽略
  - 映射文件中没有对应关系的基因位置为 0
  ↓ 缺失值填充 + Z-score 标准化（在映射后的基因空间）
标准化后: (361 × 15055)
训练集: (270 × 15055)  [只取训练集样本]
```

**关键点**：
- **统一后的基因数 `G = 15055`**（不是 5000，而是 RNA 和 METH 的实际交集）
- 所有组学最终都使用相同的 15055 个基因
- **MIR 映射**：映射矩阵的列数固定为 15055，确保与 RNA/METH 对齐
- 训练集维度：`(270 × 15055)`，验证集维度：`(91 × 15055)`

---

## 阶段3：Gene-level Autoencoder 编码

### 🔄 处理流程

**执行位置**：`simdeep/tools/generate_gene_pca_tsv.py:181-259`

#### 3.1 GeneEnc Autoencoder 架构

**定义位置**：`simdeep/tools/generate_gene_pca_tsv.py:181-196`

```python
class GeneEnc(nn.Module):
    def __init__(self, d, hid=128):
        # d = d_gene（隐向量维度，默认 32 或 64）
        # 编码器：1 → 128 → d_gene
        # 解码器：d_gene → 128 → 1
```

**工作原理**：
- 输入：`(S, G)` - 每个样本的每个基因是一个标量值，其中 `G = 15055`（对齐后的共同基因数）
- 编码：将每个基因的值编码为 `d_gene` 维向量（默认 64）
- 输出：`(S, G, d_gene)` - 每个样本的每个基因都有 `d_gene` 维表示

#### 3.2 训练过程

**执行位置**：`simdeep/tools/generate_gene_pca_tsv.py:197-215`

1. **对每个组学分别训练**
   - RNA：`Z_mrna = train_gene_autoencoder(X_mrna_z, d_gene, epochs, batch_size)`
   - METH：`Z_meth = train_gene_autoencoder(X_meth_z, d_gene, epochs, batch_size)`
   - MIR：`Z_mir = train_gene_autoencoder(X_gene_mir, d_gene, epochs, batch_size)`（如果存在）

2. **训练参数**
   - `d_gene`：隐向量维度（**run.sh 中为 64**，默认 32，可通过 `--d-gene` 调整）
   - `epochs`：训练轮数（**run.sh 中为 10**，默认 1，可通过 `--epochs` 调整）
   - `batch_size`：批次大小（**run.sh 中为 64**，默认 64，可通过 `--batch-size` 调整）
   - 优化器：Adam（`lr=1e-3`, `weight_decay=1e-5`）
   - 损失函数：MSE（均方误差）

3. **输出**
   - `Z_mrna`: `(S, G, d_gene)` - RNA 的基因级编码
   - `Z_meth`: `(S, G, d_gene)` - METH 的基因级编码
   - `Z_mir`: `(S, G, d_gene)` - MIR 的基因级编码（如果存在）

#### 3.3 多模态融合（可选）

**执行位置**：`simdeep/tools/generate_gene_pca_tsv.py:241-259`

**为什么叫"如果多模态"？**

- **多模态模式**：当存在 2 个或更多组学时（例如：RNA + METH，或 RNA + METH + MIR）
  - 使用简单的注意力机制融合多个组学的编码
  - 生成 `Z_gene_all.npy` 文件
  - **代码逻辑**：
    ```python
    z_list = [Z_mrna, Z_meth, Z_mir]  # 过滤掉 None
    if len(z_list) > 1:  # 只有多个组学时才融合
        Z_all = fuse_simple_attention(z_list)
    ```

- **单模态模式**：如果只有一个组学（例如：只有 RNA）
  - 不会生成 `Z_gene_all.npy`（因为没有其他组学可以融合）
  - 只生成 `Z_gene_mrna.npy`（或对应的单个组学文件）

**融合过程**（多模态时）：
```python
Z_all = fuse_simple_attention([Z_mrna, Z_meth, Z_mir])
```
- 使用注意力机制为每个组学分配权重
- 加权融合多个组学的编码
- 结果：`Z_gene_all`: `(S, G, d_gene)` - 融合后的多模态编码

### 📁 生成的文件

#### 训练集 Gene-level 编码
```
data/train/integrated/gene_level/
├── gene_list.json        # 基因列表（JSON 格式）
├── sample_list.json      # 样本列表（JSON 格式）
├── Z_gene_mrna.npy       # RNA 编码：(S_train × G × d_gene)
├── Z_gene_meth.npy       # METH 编码：(S_train × G × d_gene)
├── Z_gene_mirna.npy      # MIR 编码：(S_train × G × d_gene)（如果存在）
└── Z_gene_all.npy        # 融合编码：(S_train × G × d_gene)（如果多模态）
```

#### 验证集 Gene-level 编码
```
data/val/integrated/gene_level/
├── gene_list.json        # 基因列表（JSON 格式）
├── sample_list.json      # 样本列表（JSON 格式）
├── Z_gene_mrna.npy       # RNA 编码：(S_val × G × d_gene)
├── Z_gene_meth.npy       # METH 编码：(S_val × G × d_gene)
├── Z_gene_mirna.npy      # MIR 编码：(S_val × G × d_gene)（如果存在）
└── Z_gene_all.npy        # 融合编码：(S_val × G × d_gene)（如果多模态）
```

### 📊 数据维度变化

| 输入 | 维度 | 处理 | 输出 | 维度 |
|------|------|------|------|------|
| `X_mrna` | `(S_train × 15055)` | GeneEnc autoencoder | `Z_gene_mrna.npy` | `(S_train × 15055 × d_gene)` |
| `X_meth` | `(S_train × 15055)` | GeneEnc autoencoder | `Z_gene_meth.npy` | `(S_train × 15055 × d_gene)` |
| `X_mir` | `(S_train × 15055)` | GeneEnc autoencoder | `Z_gene_mirna.npy` | `(S_train × 15055 × d_gene)` |

**示例**（`S_train=270`, `G=15055`, `d_gene=64`，**run.sh 中 `--d-gene 64`**）：
- `Z_gene_mrna.npy`: `(270 × 15055 × 64)`
- `Z_gene_meth.npy`: `(270 × 15055 × 64)`
- `Z_gene_mirna.npy`: `(270 × 15055 × 64)`（如果存在）

**文件大小估算**：
- 每个 `.npy` 文件：`270 × 15055 × 64 × 4 bytes ≈ 1.04 GB`（float32）

---

## 阶段4：Per-gene PCA 降维

### 🎯 为什么要做 PCA？

**目的和理由**：

1. **降维需求**：
   - GeneEnc autoencoder 输出：`(S × G × d_gene)` = `(270 × 15055 × 64)`
   - 每个基因有 64 维编码，总特征数：`15055 × 64 = 963,520` 维
   - **问题**：特征维度太高，容易过拟合，计算成本大

2. **PCA 的作用**：
   - **降维**：将每个基因的 64 维编码降维到 `k` 维（默认 5 维）
   - **保留主要信息**：PCA 保留方差最大的主成分，去除噪声和冗余信息
   - **降维后**：总特征数 = `15055 × 5 = 75,275` 维（相比 963,520 维减少了约 92.2%）

3. **为什么是 Per-gene PCA？**
   - **不是全局 PCA**：不是对所有基因一起做 PCA，而是**对每个基因分别做 PCA**
   - **原因**：
     - 每个基因的编码空间是独立的（不同基因的生物学意义不同）
     - 保留每个基因的独立表示能力
     - 避免不同基因之间的信息混淆
   - **方法**：对每个基因 `j`，提取 `Z_gene[:, j, :]`（所有样本的该基因编码），单独进行 PCA

4. **PCA 参数选择**：
   - `k = 5`（**run.sh 中为 5**，默认 3）：每个基因保留 5 个主成分
   - 可以通过 `--k` 参数调整（例如：`--k 3` 或 `--k 10`）
   - 通常 `k` 远小于 `d_gene`（64），实现有效降维

### 🔄 处理流程

**执行位置**：`simdeep/tools/generate_gene_pca_tsv.py:23-43, 266-279`

#### 4.1 训练集：Fit PCA 模型

**执行位置**：`simdeep/tools/generate_gene_pca_tsv.py:290-303`

1. **对每个基因分别进行 PCA**
   - 对于每个基因 `j`（`j = 1, 2, ..., G`，其中 `G = 15055`）：
     - 提取该基因在所有样本上的编码：`Z_gene[:, j, :]` → `(S_train × d_gene)`
       - 示例：`(270 × 64)` - 270 个样本，每个样本该基因的 64 维编码
     - 对该矩阵进行 PCA，保留前 `k` 个主成分（默认 `k=5`，可通过 `--k` 调整）
     - 结果：`(S_train × k)` - 每个样本的该基因的 `k` 维表示
       - 示例：`(270 × 5)` - 270 个样本，每个样本该基因的 5 个主成分

2. **保存 PCA 模型**
   - 对每个组学（RNA、METH、MIR），保存所有基因的 PCA 模型
   - 格式：Pickle 文件（`.pkl`）
   - 每个组学保存一个 `.pkl` 文件，包含 `G = 15055` 个 PCA 模型

3. **生成特征矩阵**
   - 对每个组学，将所有基因的 PCA 结果拼接：
     - 每个基因贡献 `k` 个特征
     - 总特征数：`G × k = 15055 × 5 = 75275`
     - 结果：`(S_train × G×k)` 特征矩阵
       - 示例：`(270 × 75275)` - 270 个样本，每个样本有 75275 个特征

#### 4.2 验证集：Transform（使用训练集的 PCA 模型）

**执行位置**：`simdeep/tools/generate_gene_pca_tsv.py:305-325`

1. **加载训练集的 PCA 模型**
   - 从 `train/integrated/pca_models/` 加载 `.pkl` 文件

2. **对验证集应用相同的 PCA 变换**
   - 对每个基因 `j`：
     - 提取验证集的编码：`Z_gene_val[:, j, :]` → `(S_val × d_gene)`
     - 使用训练集的 PCA 模型进行 `transform`（不是 `fit`）
     - 结果：`(S_val × k)`

3. **生成特征矩阵**
   - 拼接所有基因的 PCA 结果：`(S_val × G×k)`

### 📁 生成的文件

#### PCA 模型（训练集）
```
data/train/integrated/pca_models/
├── pca_models_rna.pkl    # RNA 模态的所有基因的 PCA 模型
├── pca_models_meth.pkl   # METH 模态的所有基因的 PCA 模型
└── pca_models_mir.pkl    # MIR 模态的所有基因的 PCA 模型（如果存在）
```

**文件内容**（Pickle 格式）：
```python
{
    'genes': [gene_list],      # 基因列表（15055 个基因）
    'k': 5,                    # PCA 分量数（**run.sh 中为 5**，默认 3，可通过 --k 调整）
    'random_state': 0,         # 随机种子
    'models': [                # 每个基因的 PCA 模型列表（15055 个模型）
        PCA_model_gene1,
        PCA_model_gene2,
        ...
        PCA_model_gene15055
    ]
}
```

#### PCA 特征矩阵（训练集）
```
data/train/integrated/
├── rna_gene_pca.tsv      # RNA 模态：(S_train × G×k + 1)
├── meth_gene_pca.tsv     # METH 模态：(S_train × G×k + 1)
└── mir_gene_pca.tsv      # MIR 模态：(S_train × G×k + 1)（如果存在）
```

**注意**：
- `mir_gene_pca.tsv` **只有在提供了 `mir.tsv` 和 `--mirna-map` 参数时才会生成**
- 如果当前目录下没有这个文件，说明：
  1. 没有提供 `mir.tsv` 文件，或
  2. 没有在 `run.sh` 中传递 `--mirna-map` 参数，或
  3. 还没有运行过训练流程
- **解决方法**：确保 `run.sh` 中包含 `--mirna-map data/mir_to_gene.tsv` 参数，然后重新运行 `./run.sh`

**文件格式**（TSV）：
- 第一列：`Samples`（样本 ID）
- 后续列：`gene1_PC1`, `gene1_PC2`, ..., `gene1_PC5`, `gene2_PC1`, ..., `gene15055_PC5`
- 总列数：`1 + G×k = 1 + 15055×5 = 75276` 列

#### PCA 特征矩阵（验证集）
```
data/val/integrated/
├── rna_gene_pca.tsv      # RNA 模态：(S_val × G×k + 1)
├── meth_gene_pca.tsv     # METH 模态：(S_val × G×k + 1)
└── mir_gene_pca.tsv      # MIR 模态：(S_val × G×k + 1)（如果存在）
```

### 📊 数据维度变化

| 输入 | 维度 | 处理 | 输出 | 维度 |
|------|------|------|------|------|
| `Z_gene_mrna.npy` | `(S_train × 15055 × 64)` | Per-gene PCA (fit) | `rna_gene_pca.tsv` | `(S_train × 75275)` |
| `Z_gene_meth.npy` | `(S_train × 15055 × 64)` | Per-gene PCA (fit) | `meth_gene_pca.tsv` | `(S_train × 75275)` |
| `Z_gene_mirna.npy` | `(S_train × 15055 × 64)` | Per-gene PCA (fit) | `mir_gene_pca.tsv` | `(S_train × 75275)` |
| `Z_gene_mrna.npy` (val) | `(S_val × 15055 × 64)` | Per-gene PCA (transform) | `rna_gene_pca.tsv` (val) | `(S_val × 75275)` |

**详细维度变化**（`S_train=270`, `G=15055`, `d_gene=64`（**run.sh 中 `--d-gene 64`**）, `k=5`（**run.sh 中 `--k 5`**））：
- **输入**：`Z_gene_mrna.npy` = `(270 × 15055 × 64)`
  - 对每个基因 `j`：提取 `(270 × 64)` 矩阵
  - 进行 PCA，保留 5 个主成分：`(270 × 5)`
  - 拼接所有 15055 个基因：`(270 × 75275)`，其中 `75275 = 15055 × 5`
- **输出**：`rna_gene_pca.tsv` = `(270 × 75276)`（包含 Samples 列）
- **验证集**：`rna_gene_pca.tsv` (val) = `(91 × 75276)`

**文件大小估算**：
- 每个 `.tsv` 文件：`270 × 75276 × 8 bytes ≈ 162.6 MB`（假设 float64，包含 Samples 列）

---

## 阶段5：DeepProg 训练与预测

### 🔄 处理流程

**执行位置**：`simdeep/tools/external_validation.py:148-291`

#### 5.1 初始化 SimDeepBoosting

**执行位置**：`simdeep/tools/external_validation.py:152-184`

1. **发现可用的模态**（动态构建）
   - **代码位置**：`simdeep/tools/external_validation.py:156-166`
   - 检查 `train/integrated/` 目录下是否存在 `*_gene_pca.tsv` 文件
   - **动态构建** `TRAINING_TSV` 字典（**不是必须三个模态一起**）：
     ```python
     TRAINING_TSV = {}
     if os.path.exists('data/train/integrated/rna_gene_pca.tsv'):
         TRAINING_TSV['RNA'] = 'data/train/integrated/rna_gene_pca.tsv'
     if os.path.exists('data/train/integrated/meth_gene_pca.tsv'):
         TRAINING_TSV['METH'] = 'data/train/integrated/meth_gene_pca.tsv'
     if os.path.exists('data/train/integrated/mir_gene_pca.tsv'):
         TRAINING_TSV['MIR'] = 'data/train/integrated/mir_gene_pca.tsv'
     ```
   - **重要说明**：
     - `TRAINING_TSV` 是**动态构建**的，只包含**实际存在的模态文件**
     - 可以是 1 个模态（只有 RNA）、2 个模态（RNA + METH）、或 3 个模态（RNA + METH + MIR）
     - **不是必须三个模态一起**，而是"存在哪些模态就添加哪些"
     - 例如：如果只有 `rna_gene_pca.tsv` 和 `meth_gene_pca.tsv`，则 `TRAINING_TSV = {'RNA': ..., 'METH': ...}`（不包含 MIR）

2. **创建 SimDeepBoosting 实例**
   - 输入：
     - `training_tsv`: `TRAINING_TSV`（动态构建的字典，包含所有存在的模态特征矩阵）
     - `survival_tsv`: `data/train/train_survival.tsv`
     - `use_autoencoders=False`（**重要**：不使用 DeepProg 内部的 Keras autoencoder）
     - `nb_it`: 集成迭代次数（**run.sh 中为 10**，默认 1）
     - `epochs`: 每个模型的训练轮数（**run.sh 中为 20**，通过 `--boost-epochs` 参数设置，默认 3）
     - 其他参数：
       - `nb_features`: 特征选择数量（**run.sh 中为 50**，默认 200）
       - `nb_threads`: 并行线程数（**run.sh 中为 1**，默认 1）
       - `seed`: 随机种子（**run.sh 中为 42**，默认 10045）
       - `split_n_fold`: 交叉验证折数（**run.sh 中未设置，使用默认值 3**）

#### 5.2 训练过程

**执行位置**：`simdeep/simdeep_boosting.py`（DeepProg 内部）

1. **特征选择**
   - 对每个模态的特征矩阵进行特征选择（保留前 `nb_features` 个特征，默认 50）

2. **集成训练**
   - 训练 `nb_it` 个独立的模型（默认 10 个）
   - 每个模型使用不同的随机种子
   - 每个模型内部可能包含多个子模型（取决于 `split_n_fold`）

3. **聚类与风险分组**
   - 使用 K-means 聚类将样本分为风险组（默认 2 组）
   - 计算每个样本属于各组的概率

#### 5.3 预测过程

**执行位置**：`simdeep/tools/external_validation.py:186-291`

1. **全数据集预测**
   - 使用训练好的模型对**所有样本**（训练集 + 验证集）进行预测
   - 输出：每个样本的标签和概率

2. **验证集预测**
   - 单独对验证集进行预测和评估
   - 计算验证集的 C-index 和 p-value

### 📁 涉及的文件

**输入文件**：
- `data/train/integrated/rna_gene_pca.tsv`
- `data/train/integrated/meth_gene_pca.tsv`
- `data/train/integrated/mir_gene_pca.tsv`（如果存在）
- `data/train/train_survival.tsv`

**中间文件**（DeepProg 内部生成，通常不直接访问）：
- `data/integrated/external_validation/` 目录下的临时文件

### 📊 数据维度变化

| 输入 | 维度 | 处理 | 输出 | 维度 |
|------|------|------|------|------|
| `rna_gene_pca.tsv` | `(S_train × G×k)` | DeepProg 训练 | 模型参数 | - |
| `train_survival.tsv` | `(S_train × 3)` | 生存分析 | 风险分组 | - |

**示例**（`S_train=270`, `G×k=25000`）：
- 输入特征矩阵：`(270 × 25000)`（每个模态）
- 特征选择后：`(270 × nb_features)`（例如 `nb_features=50`）
- 输出：每个样本的标签（0 或 1）和概率（0-1 之间的浮点数）

---

## 阶段6：结果输出

### 🔄 处理流程

**执行位置**：`simdeep/tools/external_validation.py:186-291`

1. **生成预测标签**
   - 对全数据集和验证集分别生成标签文件

2. **计算评估指标**
   - C-index（Concordance Index）：衡量预测准确性
   - p-value：生存曲线差异的显著性检验

3. **生成可视化**
   - Kaplan-Meier 生存曲线图（PDF 格式）

### 📁 生成的文件

#### 评估指标
```
data/integrated/external_validation/
├── metrics_history.tsv   # 历史运行记录（追加模式，保留在根目录）
└── {timestamp}_seed{seed}/
    └── metrics.tsv       # 每次实验的指标（保存在实验文件夹中）
```

**`metrics.tsv` 格式**：
```text
train_pvalue_full	train_cindex_full	val_pvalue	val_cindex
0.0012	0.7234	0.0456	0.6789
```

**`metrics_history.tsv` 格式**：
```text
timestamp	seed	train_pvalue	train_cindex	val_pvalue	val_cindex
2024-12-01 08:00:00	42	0.0012	0.7234	0.0456	0.6789
2024-12-01 09:00:00	100	0.0023	0.7123	0.0567	0.6678
...
```

#### 预测标签
每次实验的结果保存在独立的文件夹中（格式：`{timestamp}_seed{seed}/`）：
```
data/integrated/external_validation/
├── metrics_history.tsv                    # 所有实验的历史记录（保留在根目录）
├── data_split_analysis.png                # 数据划分分析图（保留在根目录）
├── {timestamp}_seed{seed}/                # 每次实验的独立文件夹
│   ├── metrics.tsv                        # 本次实验的评估指标
│   ├── external_validation_full_labels.tsv       # 全数据集标签
│   └── external_validation_val_test_labels.tsv   # 验证集标签
└── ...
```

**`external_validation_full_labels.tsv` 格式**：
```text
sample_id	label	proba_0	days	event
GSM2806761	1	0.3332	724	1
GSM4779598	0	0.6668	567	0
...
```

**列说明**：
- `sample_id`：样本 ID
- `label`：聚类簇编号（0/1 等，表示风险组）
- `proba_0`：样本属于簇 0 的概率（通常作为低风险概率）
- `days`：生存时间（来自 `survival.tsv`）
- `event`：结局事件（1=死亡，0=删失）

#### 可视化文件
每次实验的KM图保存在对应的实验文件夹中：
```
data/integrated/external_validation/{timestamp}_seed{seed}/
├── external_validation_full_labels_KM_plot_boosting_full_*.pdf
├── external_validation_full_proba_KM_plot_boosting_full_*.pdf
├── external_validation_val_labels_KM_plot_boosting_val_*.pdf
└── external_validation_val_proba_KM_plot_boosting_val_*.pdf
```

**内容**：Kaplan-Meier 生存曲线图，展示不同风险组的生存差异

**生成方式**：
- 通过 `simdeep/coxph_from_r.py` 中的 `coxph` 函数生成（`do_KM_plot=True`）
- **不依赖** `simdeep/plot_utils.py`（该模块用于生成 KDE 图，当前流程中不使用）

### 📊 数据维度变化

| 输入 | 维度 | 处理 | 输出 | 维度 |
|------|------|------|------|------|
| 模型预测 | - | 评估 | `metrics.tsv` | `(1 × 4)` |
| 模型预测 | - | 标签生成 | `*_labels.tsv` | `(S × 5)` |

**示例**（`S=360`）：
- `external_validation_full_labels.tsv`: `(360 × 5)`（保存在实验文件夹中）
- `external_validation_val_test_labels.tsv`: `(90 × 5)`（保存在实验文件夹中）

**注意**：每次实验的所有结果文件（标签文件、metrics.tsv、PDF图）都保存在独立的文件夹中，文件夹命名格式为 `{timestamp}_seed{seed}`，例如 `20251207_0636_seed42/`。这样可以避免多次运行覆盖之前的结果，便于管理和对比不同实验。

---

## 数据维度变化总览

### 完整流程示例（实际项目数据）

假设：
- `S = 361`（总样本数）
- `S_train = 270`（训练集样本数，75%）
- `S_val = 91`（验证集样本数，25%）
- `G_RNA_原始 = 15629`（RNA 原始基因数）
- `G_METH_原始 = 19883`（METH 原始基因数）
- `G = 15055`（对齐后的共同基因数，RNA 和 METH 的交集）
- `G_mir = 1000`（miRNA 数量，映射到基因空间后对齐到 15055）
- `d_gene = 64`（autoencoder 隐向量维度）
- `k = 5`（每个基因的 PCA 分量数）

### 维度变化表

| 阶段 | 文件/变量 | 维度 | 说明 |
|------|-----------|------|------|
| **阶段0** | `data/rna.tsv` | `(361 × 15629)` | 原始 RNA 矩阵（行=样本，列=基因） |
| **阶段0** | `data/meth.tsv` | `(361 × 19883)` | 原始 METH 矩阵（行=样本，列=基因） |
| **阶段0** | `data/mir.tsv` | `(361 × G_mir)` | 原始 MIR 矩阵（如果存在） |
| **阶段0** | `data/survival.tsv` | `(361 × 3)` | 生存信息 |
| **阶段1** | `train/raw/rna.tsv` | `(15629 × 270)` | 训练集 RNA（转置后：行=基因，列=样本） |
| **阶段1** | `val/raw/rna.tsv` | `(15629 × 91)` | 验证集 RNA（转置后：行=基因，列=样本） |
| **阶段2** | 基因对齐后 | `(15055 × 270)` | **关键**：取 RNA 和 METH 的基因交集 |
| **阶段2** | `X_mrna` | `(270 × 15055)` | 标准化后的 RNA（内存，转置为样本×基因） |
| **阶段2** | `X_meth` | `(270 × 15055)` | 标准化后的 METH（内存） |
| **阶段2** | `X_mir` | `(270 × 15055)` | 映射后的 MIR（内存，如果存在） |
| **阶段3** | `Z_gene_mrna.npy` | `(270 × 15055 × 64)` | RNA 编码 |
| **阶段3** | `Z_gene_meth.npy` | `(270 × 15055 × 64)` | METH 编码 |
| **阶段3** | `Z_gene_mirna.npy` | `(270 × 15055 × 64)` | MIR 编码（如果存在） |
| **阶段4** | `rna_gene_pca.tsv` (train) | `(270 × 75276)` | RNA PCA 特征（包含 Samples 列） |
| **阶段4** | `meth_gene_pca.tsv` (train) | `(270 × 75276)` | METH PCA 特征 |
| **阶段4** | `mir_gene_pca.tsv` (train) | `(270 × 75276)` | MIR PCA 特征（如果存在） |
| **阶段4** | `rna_gene_pca.tsv` (val) | `(91 × 75276)` | RNA PCA 特征（验证集） |
| **阶段5** | DeepProg 输入 | `(270 × 75275)` × 3 | 三个模态的特征矩阵（不含 Samples 列） |
| **阶段6** | `*_labels.tsv` | `(361 × 5)` | 预测标签和概率 |

### 关键维度计算

1. **基因对齐（阶段2）**：
   - RNA 原始：15629 个基因
   - METH 原始：19883 个基因
   - **共同基因**：15055 个基因（交集）
   - 被排除：RNA 独有 574 个，METH 独有 4828 个

2. **Gene-level 编码维度（阶段3）**：
   - 输入：`(S × G)` = `(270 × 15055)` → 输出：`(S × G × d_gene)` = `(270 × 15055 × 64)`
   - 每个基因从 1 维扩展到 `d_gene = 64` 维

3. **PCA 降维（阶段4）**：
   - 输入：`(S × G × d_gene)` = `(270 × 15055 × 64)` → 输出：`(S × G×k)` = `(270 × 75275)`
   - 每个基因从 `d_gene = 64` 维降维到 `k = 5` 维
   - 总特征数：`G × k = 15055 × 5 = 75275`（不含 Samples 列）

4. **最终特征矩阵（阶段5）**：
   - 每个模态：`(S × G×k)` = `(270 × 75275)`
   - 三个模态：`(270 × 75275)` × 3（DeepProg 会分别处理）

---

## 文件依赖关系图

```
原始输入
├── rna.tsv ──────────────┐
├── meth.tsv ─────────────┤
├── mir.tsv ──────────────┤
├── survival.tsv ─────────┤
└── mir_to_gene.tsv ──────┘
         │
         ▼
    阶段1：数据划分
         │
         ├── train/raw/ ────┐
         │   ├── rna.tsv    │
         │   ├── meth.tsv   │
         │   └── mir.tsv    │
         │                  │
         └── val/raw/ ──────┤
             ├── rna.tsv    │
             ├── meth.tsv   │
             └── mir.tsv    │
                            │
                            ▼
                    阶段2：基因对齐与预处理
                            │
                            ▼
                    阶段3：Gene-level Autoencoder
                            │
                            ├── train/integrated/gene_level/
                            │   ├── Z_gene_mrna.npy
                            │   ├── Z_gene_meth.npy
                            │   └── Z_gene_mirna.npy
                            │
                            ▼
                    阶段4：Per-gene PCA
                            │
                            ├── train/integrated/pca_models/
                            │   ├── pca_models_rna.pkl
                            │   ├── pca_models_meth.pkl
                            │   └── pca_models_mir.pkl
                            │
                            ├── train/integrated/
                            │   ├── rna_gene_pca.tsv
                            │   ├── meth_gene_pca.tsv
                            │   └── mir_gene_pca.tsv
                            │
                            └── val/integrated/
                                ├── rna_gene_pca.tsv
                                ├── meth_gene_pca.tsv
                                └── mir_gene_pca.tsv
                                    │
                                    ▼
                            阶段5：DeepProg 训练
                                    │
                                    ▼
                            阶段6：结果输出
                                    │
                                    └── integrated/external_validation/
                                        ├── metrics.tsv
                                        ├── metrics_history.tsv
                                        ├── *_labels.tsv
                                        └── *.pdf
```

---

## 总结

### 关键点

1. **两个 Autoencoder 层**：
   - **GeneEnc（PyTorch）**：在数据预处理阶段，将每个基因从 1 维编码为 `d_gene` 维（**总是使用**）
   - **DeepProg Keras AE**：DeepProg 内部的 autoencoder（**当前流程中禁用**，`use_autoencoders=False`）

2. **PCA 的作用**：
   - 对每个基因的 `d_gene` 维编码进行降维
   - 保留前 `k` 个主成分
   - 确保训练集和验证集使用相同的 PCA 模型（严格的外部验证）

3. **数据流**：
   - 原始矩阵 → 划分 → 对齐 → 标准化 → GeneEnc 编码 → PCA 降维 → DeepProg 训练 → 预测输出

4. **文件组织**：
   - `train/` 和 `val/` 目录分别存放训练集和验证集的数据
   - `integrated/` 目录存放处理后的特征和最终结果
   - `gene_level/` 目录存放 3D 编码（体积较大，可按需归档）

---

## 脚本调用关系说明

### 主要入口脚本

1. **`run.sh`**（用户入口）
   - 调用：`simdeep/tools/external_validation.py`
   - 作用：设置环境变量和参数，启动完整流程

2. **`simdeep/tools/external_validation.py`**（主流程脚本）
   - 调用：
     - `simdeep/tools/generate_gene_pca_tsv.py`（多次调用，用于不同阶段）
     - `simdeep/simdeep_boosting.py`（DeepProg 训练）
   - 作用：协调整个流程，包括数据划分、特征生成、模型训练

3. **`simdeep/tools/generate_gene_pca_tsv.py`**（特征生成脚本）
   - 被调用：由 `external_validation.py` 调用
   - 调用：
     - `simdeep/extract_data.py`（数据加载）
     - `simdeep/deepmodel_base.py`（autoencoder 构建，但当前流程中不使用）
   - 作用：生成 Gene-level 编码和 PCA 特征

4. **`simdeep/simdeep_boosting.py`**（DeepProg 集成训练）
   - 被调用：由 `external_validation.py` 调用
   - 调用：
     - `simdeep/simdeep_analysis.py`（单个模型训练）
     - `simdeep/extract_data.py`（数据加载）
     - `simdeep/deepmodel_base.py`（autoencoder，但当前流程中 `use_autoencoders=False`）
     - `simdeep/coxph_from_r.py`（生存分析）
     - `simdeep/survival_utils.py`（生存分析工具）
   - 作用：集成多个 SimDeep 模型，进行 boosting 训练

5. **`simdeep/simdeep_analysis.py`**（单个模型训练）
   - **被调用**：由 `simdeep_boosting.py` 调用（**当前流程中使用**）
   - **调用位置**：`simdeep/simdeep_boosting.py:508` 创建 `SimDeep` 实例
   - **调用**：
     - `simdeep/deepmodel_base.py`（autoencoder，但当前流程中 `use_autoencoders=False`，不使用）
     - `simdeep/extract_data.py`（数据加载，**使用**）
     - `simdeep/coxph_from_r.py`（生存分析，**使用**）
     - `simdeep/survival_utils.py`（生存分析工具，**使用**）
     - `simdeep/survival_model_utils.py`（聚类与生存模型，**使用**）
     - `simdeep/plot_utils.py`（KDE 可视化，**当前流程中不使用**）
   - **作用**：训练单个 SimDeep 模型（每个 boosting 迭代创建一个实例）
   - **使用情况**：**被使用** - `SimDeepBoosting` 会创建多个 `SimDeep` 实例进行集成训练

### 辅助脚本

- **`simdeep/config.py`**：配置文件，定义默认参数（**使用**）
- **`simdeep/simdeep_utils.py`**：工具函数（模型保存/加载等，**使用**）
- **`simdeep/plot_utils.py`**：可视化工具（生成 KDE 图等，**当前流程中不使用**）
  - **说明**：虽然 `simdeep_analysis.py` 中导入了 `plot_utils.py`，但在当前流程（`external_validation.py`）中不会调用 `plot_kernel_for_test_sets` 方法
  - **实际可视化**：当前流程通过 `coxph_from_r.py` 生成 Kaplan-Meier 生存曲线图（PDF 格式），不依赖 `plot_utils.py`

### 调用流程图

```
run.sh
  └─> external_validation.py
       ├─> generate_gene_pca_tsv.py (阶段2-4：数据预处理、编码、PCA)
       │    ├─> extract_data.py (数据加载)
       │    └─> deepmodel_base.py (GeneEnc autoencoder，PyTorch)
       │
       └─> simdeep_boosting.py (阶段5：DeepProg 训练)
            └─> simdeep_analysis.py (单个模型训练)
                 ├─> extract_data.py (数据加载)
                 ├─> coxph_from_r.py (生存分析)
                 ├─> survival_utils.py (生存分析工具)
                 ├─> survival_model_utils.py (聚类模型)
                 └─> plot_utils.py (可视化，可选)
```

### 关键说明

1. **`entrez2ensg.tsv` 的使用**：
   - 只在 `survival_utils.py` 的 `_load_data_from_tsv_transposee` 函数中使用
   - **只有当文件名包含 "entrez" 时才会使用**
   - 如果您的文件名是 `rna.tsv`、`meth.tsv` 等（不包含 "entrez"），**此文件不会被使用**

2. **`TRAINING_TSV` 的构建**：
   - 在 `external_validation.py:156-166` 中**动态构建**
   - 只包含**实际存在的模态文件**（可以是 1 个、2 个或 3 个模态）
   - **不是必须三个模态一起**，而是"存在哪些模态就添加哪些"

3. **参数来源**：
   - 默认值：`external_validation.py` 中的 `argparse` 定义
   - 实际值：`run.sh` 中通过命令行参数传入
   - 文档中标注了 **run.sh 中的实际值**，便于理解当前配置

---

## 相关文档

- **主项目 README**：`../README.md`
- **数据目录说明**：`README.md`
- **项目配置说明**：`../项目配置说明.md`
- **MIRNA 处理说明**：`../MIRNA处理说明.md`

